#! /usr/bin/env python

"""
Purpose of this script is to hard filter our mtdna
for analysis
"""

import os
import sys
from collections import OrderedDict

## load samples from file
def load_samples(f):
	s, b = [], []
	with open(f, "r") as ff:
		for line in ff:
			if line.startswith("#"):
				continue
			bam_entry = line.strip().split().pop(0)
			folder, bn = os.path.split(bam_entry)
			iid = os.path.splitext(bn)[0]
			s.append(iid)
			b.append(bam_entry)
	return s, dict(zip(s,b))

# root directory for pipeline outputs
OUTDIR = os.path.expandvars(config["outdir"])
# temporary directory used by Java; probably should point to scratch space
TMPDIR = os.path.expandvars(config["tmpdir"])
# reference genome
REF = os.path.expandvars(config["reference"])
# list of *.bam files to process, which are assumed to be named like {sample}.bam
SAMPLES = os.path.expandvars(config["samples"])
## get list of samples and chunks to call
samples, bam_list = load_samples(SAMPLES)

## read configuration stuff
gvcfs = OrderedDict()
for s in samples:
	gvcfs[s] = os.path.join(OUTDIR, "gvcfs/{}.g.vcf.gz".format(s))

final_gvcfs = [ os.path.join(OUTDIR, "gvcfs/{}.g.vcf.gz".format(s)) for s in samples ]

## final targets
rule all:
	input:
		final_gvcfs,
		os.path.join(OUTDIR, "passed.joint.vcf.gz")

## final tidy-up
rule tidy_up:
	input:
		vcf = os.path.join(OUTDIR, "filtered.joint.vcf.gz"),
	output:
		os.path.join(OUTDIR, "passed.joint.vcf.gz")
	params:
		ref = REF,
		memory = str(int(config["memory"])),
		region = config["region"],
	shell:
		r"""
		gatk --java-options "-Xmx{params.memory}g" SelectVariants \
			-R {params.ref} \
			-V {input.vcf} \
			--intervals {params.region} \
			--set-filtered-gt-to-nocall \
			--exclude-filtered \
			--remove-unused-alternates \
			-O {output}
		"""



## add entries to FILTER per GATK4 hard-filtering best practices; don't actually apply the filter
# see https://informatics.fas.harvard.edu/whole-genome-resquencing-for-population-genomics-fastq-to-vcf.html#variantcalling
rule filter_vars:
	input:
		vcf = os.path.join(OUTDIR, "combined.joint.vcf.gz"),
	output:
		os.path.join(OUTDIR, "filtered.joint.vcf.gz")
	params:
		ref = REF,
		memory = str(int(config["memory"])),
		min_RPRS_SNV = config["min_RPRS_SNV"],
		min_RPRS_indel = config["min_RPRS_indel"],
		min_QD = config["min_QD"],
		max_FS_SNV = config["max_FS_SNV"],
		max_SOR_SNV = config["max_SOR_SNV"],
		max_FS_indel = config["max_FS_indel"],
		max_SOR_indel = config["max_SOR_indel"],
		min_MQ = config["min_MQ"],
		min_MQRS = config["min_MQRS"],
		region = config["region"]
	shell:
		r"""
		gatk --java-options "-Xmx{params.memory}g" VariantFiltration \
			-R {params.ref} \
			-V {input.vcf} \
			--intervals {params.region} \
			--invalidate-previous-filters \
			--genotype-filter-expression "!vc.hasAttribute('DP')" \
			--genotype-filter-name "NoDP" \
			--filter-expression "(vc.hasAttribute('QD') && QD < {params.min_QD})" \
			--filter-name "LowQD" \
			--filter-expression "(vc.isSNP() && (vc.hasAttribute('ReadPosRankSum') && ReadPosRankSum < {params.min_RPRS_SNV})) || ((vc.isIndel() || vc.isMixed()) && (vc.hasAttribute('ReadPosRankSum') && ReadPosRankSum < {params.min_RPRS_indel})) " \
			--filter-name "PosBias" \
			--filter-expression "(vc.isSNP() && ((vc.hasAttribute('FS') && FS > {params.max_FS_SNV}) || (vc.hasAttribute('SOR') &&  SOR > {params.max_SOR_SNV}))) || ((vc.isIndel() || vc.isMixed()) && ((vc.hasAttribute('FS') && FS > {params.max_FS_indel}) || (vc.hasAttribute('SOR') &&  SOR > {params.max_SOR_indel})))" \
			--filter-name "StrandBias" \
			--filter-expression "vc.isSNP() && ((vc.hasAttribute('MQ') && MQ < {params.min_MQ}) || (vc.hasAttribute('MQRankSum') && MQRankSum < {params.min_MQRS}))" \
			--filter-name "LowMQ" \
			-O {output}
		"""

## DISCOVERY MODE: perform joint calling
rule joint_genotype:
	input:
		combined_gvcf = os.path.join(OUTDIR, "combined.g.vcf.gz")
	output:
		joint_vcf = os.path.join(OUTDIR, "combined.joint.vcf.gz")
	params:
		maxalleles = config["max_alleles"],
		ref = REF,
		memory = str(int(config["memory"]))
	shell:
		r"""
		gatk --java-options "-Xmx{params.memory}g" GenotypeGVCFs \
			-R {params.ref} \
			-V {input.combined_gvcf} \
			-O {output.joint_vcf} \
			--max-alternate-alleles {params.maxalleles}
		"""

## DISCOVERY MODE: join GVCFs in prep for joint calling
rule combine_gvcfs:
	input:
		gvcf_list = os.path.join(OUTDIR, "gvcfs/gvcfs.list"),
	output:
		combined_gvcf = os.path.join(OUTDIR, "combined.g.vcf.gz")
	params:
		ref = REF,
		memory = str(int(config["memory"]))
	shell:
		r"""
		gatk --java-options "-Xmx{params.memory}g" CombineGVCFs \
			-R {params.ref} \
			--variant {input.gvcf_list} \
			-O {output.combined_gvcf}
		"""

## make lists of GVCF files by chunk
rule make_gvcf_lists:
	output:
		os.path.join(OUTDIR, "gvcfs/gvcfs.list")
	run:
		outfile = os.path.join(OUTDIR, "gvcfs/gvcfs.list")
		with open(outfile, "w") as list_file:
		    for key, value in gvcfs.items():
		        print(value, file = list_file)


rule call_variants:
	input:
		bam = lambda w: bam_list[w.sample],
		ref = REF,
	output:
		# output is organized by chunk, in anticipation of joing calling by chunk
		os.path.join(OUTDIR, "gvcfs/{sample}.g.vcf.gz")
	params:
		memory = str(int(config["memory"])),
		interval_file = config["region"]
	shell:
		r"""
		gatk --java-options "-Xmx{params.memory}g" HaplotypeCaller \
			-R {input.ref} \
			-I {input.bam} \
			-O {output} \
			-L {params.interval_file} \
			--genotyping-mode DISCOVERY \
			--alleles {params.known} \
			-ERC GVCF
		"""
